classdef GaussianDistribution < handle
    properties
        mu 
        cov
        dim
        prior
    end
    
    properties (Dependent)
        Expectation
        Variance
        Value               % Sample from the distribution
        H                   % Entropy
        ExpectationXt       % E[x^T]
        ExpectationXtX      % E[x^Tx]
        ExpectationXXt      % E[xx^T]
    end
  
    methods (Static, Access = private)
        function [mu, cov, prior, dim] = getDefaultDistribution()
            mu = Constants.DEFAULT_GAUSS_MU;
            cov = 1 / Constants.DEFAULT_GAUSS_PRECISION;
            prior = NaN; % By default prior for the distribution is not defined
            dim = Constants.DEFAULT_GAUSS_DIM;
        end

        function [mu, cov, prior, dim] = initParameters(varargin)
            %% [NOTE]
            % For now prior is defined by a single scalar that represents
            % the precision. Mean is 0! It is a little bit strange that prior is
            % defined using precision and distribution is defined using
            % covariance, but in the BPCA model that was the most
            % convinient way. This can be updated to accomodate for
            % other models.
            %%
            prior = NaN; % Default value for prior

            % One dimensional Gaussian
            switch nargin
                case 0
                    [mu, cov, prior, dim] = GaussianDistribution.getDefaultDistribution();
                case 1
                    mu = varargin{1};
                    if size(mu, 1) == 1
                        mu = mu'; % 'mu' is a column vector
                    end 

                    cov = eye(length(mu));
                    dim = length(mu);
    
                case {2, 3}
                    mu = varargin{1};
                    if size(mu, 1) == 1
                        mu = mu'; % 'mu' is a column vector
                    end

                    cov = varargin{2};

                    if Utility.isMatrix(cov) && ~Utility.isValidCovarianceMatrix(cov) 
                        error(['Error in class ' mfilename ': Parameter is not a valid covariance matrix.']);
                    end
    
                    % [NOTE]: For 'cov' it is okay to use 'length' because it is passed to the diag() in
                    % case it is an array!
                    if Utility.isArray(mu) && Utility.isArray(cov) && size(mu, 1) ~= length(cov) || ...
                            Utility.isArray(mu) && Utility.isMatrix(cov) && size(mu, 1) ~= size(cov, 1)
                        error(['Error in ' mfilename ': Dimensions do not match.']);
                    end

                    if nargin == 3 && ~isscalar(varargin{3})
                        error(['Error in class ' mfilename ': Precision of the prior must be a scalar or NaN.']);
                    end

                   % ------------------------------------------------------
                   % When we get this far all parameters are valid and all
                   % dimensions match
    
                    % 'mu' is an array
                    if Utility.isArray(mu)
                        dim = size(mu, 1);
                        % If it is a matrix it is already set with 'cov =
                        % varargin{2};' above
                        if ~Utility.isMatrix(cov)
                            if Utility.isArray(cov)
                                cov = diag(cov);
                            else
                                cov = cov * eye(size(mu, 1));
                            end
                        end

                    % 'mu' is a scalar        
                    else 
                        if Utility.isMatrix(cov)
                            mu  = mu * ones(size(cov, 1), 1);
                            dim = size(cov, 1);
                        elseif Utility.isArray(cov)
                            mu = mu * ones(length(cov), 1);
                            cov = diag(cov);
                            dim = length(cov);
                        else
                            % Both 'mu' and 'cov' are scalars
                            dim = 1;
                        end
                    end
                    if nargin == 3 && ~isnan(varargin{3}) % Set the prior only if not NaN is passed in for priorPrec
                        prior = GaussianDistribution(0, diag(1 / varargin{3} * ones(dim, 1)));
                    end

                case 4
                    % [NOTE] 'NaN' can be passed for priorPrec
                    % This is the case where 'dim' is explicitly set, and it
                    % can only be used for the case where 'mu' and 'cov' are
                    % scalars. This means 'cov' is just sigma^2. 
                    % In case where we want to infer the 'dim' from other params,
                    % the previous constructor should be used.
                    mu = varargin{1};
                    cov = varargin{2};
                    priorPrec = varargin{3};
                    dim = varargin{4};


                    if ~isscalar(mu) || ~isscalar(cov) || ~isscalar(priorPrec) % NaN is scalar
                        error(['Error in class ' mfilename ': Method with four parameters can be used only with scalar values for mu and cov and prior.']);
                    end
    
                    % Spherical multivariate Gaussian distribution
                    mu = mu * ones(dim, 1); % Column vector
                    cov = diag(cov * ones(dim, 1));

                    % [NOTE] This can look like infinite recursion, but it
                    % is not because here the constructor with two
                    % parameters will be called, thus this line won't be
                    % hit again!
                    if ~isnan(priorPrec)
                        prior = GaussianDistribution(0, diag(1 / priorPrec * ones(dim, 1)));
                    end
    
                otherwise
                    error(['Error in class ' mfilename ': Too many arguments passed.']);
            end
        end

    end
    
    methods
        function obj = GaussianDistribution(varargin)
            % [NOTE] We pass in priorPrec not the prior (scalar not the
            % GaussianDistribution object)
            % Parameters: mu, cov, priorPrec, dim - they are all optional
            [mu, cov, prior, dim] = GaussianDistribution.initParameters(varargin{:});

            obj.mu = mu;
            obj.cov = cov;
            obj.prior = prior;
            obj.dim = dim;
        end



        %% Methods
        % [NOTE] Gaussian parameters are correlated, don't allow setting
        % them independently (if we want to implement this properly we should make attributes private)! 
        % Also, 'dim' will never change in these updates, so for now they
        % can be set separately as long as the update doesn't change the
        % 'dim'.
        function updateParameters(obj, varargin)
            if nargin < 3
                error(['Error in class ' class(obj) ': Too few arguments passed.']);
            end
            
            [m, c, p, d] = GaussianDistribution.initParameters(varargin{:});

            if obj.dim ~= d
                error(['Error in class ' class(obj) ': Dimension cannot be changed via update method.']);
            end

            if isnan(obj.prior) && ~isnan(p) || isnan(obj.prior) && ~isnan(p)
                
                obj.prior ~= p
                error(['Error in class ' class(obj) ': Prior cannot be changed via update method.']);
            end

            obj.mu = m;
            obj.cov = c;
            obj.dim = d;
        end

        function obj = updateCovariance(obj, cov)
            if nargin < 2
                error(['Error in class ' class(obj) ': Too few arguments passed.']);
            end

            if ~Utility.isValidCovarianceMatrix(cov)
                error(['Error in class ' class(obj) ': Argument is not a valid covariance matrix.']);
            end

            if obj.dim ~= size(cov, 1)
                error(['Error in class ' class(obj) ': Dimension cannot be changed via update method.']);
            end
            
            % Update covariance
            obj.cov = cov;
        end
        
        function obj = updateMu(obj, mu)
            if nargin < 2
                error(['Error in class ' class(obj) ': Too few arguments passed.']);
            end

            if obj.dim ~= length(mu)
                error(['Error in class ' class(obj) ': Dimension cannot be changed via update method.']);
            end
            
            obj.mu = mu;
        end



        %% Getters
        function value = get.Expectation(obj)
            value = obj.mu;
        end

        function value = get.ExpectationXt(obj)
            value = obj.mu';
        end
        
        function value = get.Variance(obj)
            value = obj.cov;
        end

        function value = get.H(obj)
            value = 1/2 * log(det(obj.cov)) + obj.dim/2 * (1 + log(2 * pi)); 
        end

        function value = get.Value(obj)
            value = mvnrnd(obj.mu, obj.cov)'; % Transpose to get a column vector
        end

        function value = get.ExpectationXtX(obj)
            value = obj.mu' * obj.mu + trace(obj.cov);
        end

        function value = get.ExpectationXXt(obj)
            value = obj.mu * obj.mu' + obj.cov;
        end
    end
end