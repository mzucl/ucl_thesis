classdef GaussianDistribution < handle
    properties
        mu 
        cov
        dim
        prior
    end
    
    properties (Dependent)
        Expectation
        Variance
        Precision           % Set only if the covariance matrix is spherical or diagonal, otherwise NaN
        Value               % Sample from the distribution
        H                   % Entropy
        ExpectationXt       % E[x^T]
        ExpectationXtX      % E[x^Tx]
        ExpectationXXt      % E[xx^T]
    end
  
    methods (Static, Access = private)
        function [mu, cov, prior, dim] = getDefaultDistributionParams()
            mu = Constants.DEFAULT_GAUSS_MU;
            cov = 1 / Constants.DEFAULT_GAUSS_PRECISION;
            prior = NaN; % By default prior for the distribution is not defined
            dim = Constants.DEFAULT_GAUSS_DIM;
        end

        % [NOTE] % Left 'dim' as the last parameter because it can be
        % inferred from other parameters in some cases. 
        function [mu, cov, prior, dim] = initParameters(varargin)
            prior = NaN; % Default value for prior

            % One dimensional Gaussian
            switch nargin
                case 0
                    [mu, cov, prior, dim] = GaussianDistribution.getDefaultDistributionParams();

                case 1
                    mu = varargin{1};
                    % If the ONLY parameter is of a type GaussianDistribution that is
                    % the prior and we initialize the 'obj' and its 'prior'
                    % using that value
                    if isscalar(mu) && isa(mu, 'GaussianDistribution')
                        priorDist = mu; % Shallow copy is okay here!
                        mu = priorDist.mu;
                        cov = priorDist.cov;
                        dim = priorDist.dim;
                        prior = priorDist.copy();

                    elseif isnumeric(mu)
                        if size(mu, 1) == 1
                            mu = mu'; % 'mu' is a column vector
                        end 
    
                        cov = eye(length(mu));
                        dim = length(mu);
                    else
                        error(['Error in class ' class(obj) ': Invalid arguments passed.']);
                    end

                case {2, 3}
                    mu = varargin{1};
                    if size(mu, 1) == 1
                        mu = mu'; % 'mu' is a column vector
                    end

                    cov = varargin{2};

                    if Utility.isMatrix(cov) && ~Utility.isValidCovarianceMatrix(cov) 
                        error(['Error in class ' mfilename ': Parameter is not a valid covariance matrix.']);
                    end
    
                    % [NOTE]: For 'cov' it is okay to use 'length' because it is passed to the diag() in
                    % case it is an array!
                    if Utility.isArray(mu) && Utility.isArray(cov) && size(mu, 1) ~= length(cov) || ...
                            Utility.isArray(mu) && Utility.isMatrix(cov) && size(mu, 1) ~= size(cov, 1)
                        error(['Error in ' mfilename ': Dimensions do not match.']);
                    end

                    if nargin == 3 && ~isscalar(varargin{3})
                        error(['Error in class ' mfilename ': Precision of the prior must be a scalar or NaN.']);
                    end

                   % ------------------------------------------------------
                   % When we get this far all parameters are valid and all
                   % dimensions match
    
                    % 'mu' is an array
                    if Utility.isArray(mu)
                        dim = size(mu, 1);
                        % If it is a matrix it is already set with 'cov =
                        % varargin{2};' above
                        if ~Utility.isMatrix(cov)
                            if Utility.isArray(cov)
                                cov = diag(cov);
                            else
                                cov = cov * eye(size(mu, 1));
                            end
                        end

                    % 'mu' is a scalar        
                    else 
                        if Utility.isMatrix(cov)
                            mu  = mu * ones(size(cov, 1), 1);
                            dim = size(cov, 1);
                        elseif Utility.isArray(cov)
                            mu = mu * ones(length(cov), 1);
                            cov = diag(cov);
                            dim = length(cov);
                        else
                            % Both 'mu' and 'cov' are scalars
                            dim = 1;
                        end
                    end
                    if nargin == 3 && ~isnan(varargin{3}) % Set the prior only if not NaN is passed in for priorPrec
                        prior = GaussianDistribution(0, diag(1 / varargin{3} * ones(dim, 1)));
                    end

                case 4
                    % [NOTE] 'NaN' can be passed for 'prior'
                    % This is the case where 'dim' is explicitly set, and it
                    % can ONLY be used for the case where 'mu' and 'cov' are
                    % scalars. This means 'cov' is just sigma^2/. 
                    % In case where we want to infer the 'dim' from other params,
                    % the previous constructor should be used.
                    mu = varargin{1};
                    cov = varargin{2};
                    prior = varargin{3}; % For now this is scalar - they all have the same prior
                    dim = varargin{4};
                    
                    if ~Utility.isSingleNumber(mu) || ~Utility.isSingleNumber(cov) || ~isscalar(prior) || ...
                            ~Utility.isNaNOrInstanceOf('GaussianDistribution') || ~Utility.isSingleNumber(dim)
                        error(['Error in class ' mfilename ': Method with four parameters can be used only with scalar values for mu and cov and prior.']);
                    end
    
                    if ~Utility.isNaN(prior) && prior.dim ~= dim
                        error(['Error in class ' mfilename ': dim parameter and dimension of the prior do not align']);
                    end

                    % Spherical multivariate Gaussian distribution
                    mu = mu * ones(dim, 1); % Column vector
                    cov = diag(cov * ones(dim, 1));
    
                otherwise
                    error(['Error in class ' mfilename ': Too many arguments passed.']);
            end
        end

    end
    
    methods
        function newObj = copy(obj)
            newObj = GaussianDistribution();
            
            newObj.mu = obj.mu;
            newObj.cov = obj.cov;
            newObj.dim = obj.dim;
            
            % Copy the prior (manually)
            if ~Utility.isNaN(obj.prior)
                newObj.prior = GaussianDistribution();

                newObj.prior.mu = obj.prior.mu;
                newObj.prior.cov = obj.prior.cov;
                newObj.prior.dim = obj.prior.dim;
            end
        end

        function obj = GaussianDistribution(varargin)
            % [NOTE] We pass in priorPrec not the prior (scalar not the
            % GaussianDistribution object)
            % Parameters: mu, cov, priorPrec, dim - they are all optional
            [mu, cov, prior, dim] = GaussianDistribution.initParameters(varargin{:});

            obj.mu = mu;
            obj.cov = cov;
            obj.prior = prior;
            obj.dim = dim;
        end



        %% Methods
        % [NOTE] Gaussian parameters are correlated (via 'dim'), don't allow setting
        % them independently (if we want to implement this properly we should make attributes private)! 
        % Also, 'dim' will never change in these updates, so for now they
        % can be set separately as long as the update doesn't change the
        % 'dim'.
        function updateParameters(obj, varargin)
            % Dimension and prior cannot be changed in these update methods
            if nargin ~= 3
                error(['Error in class ' class(obj) ': Too few arguments passed.']);
            end
            
            % We can ignore 'prior' returned, but not 'dim', because 'dim'
            % can be inferred from the 'mu' and 'cov' params, thus can be
            % changed, unlike the 'prior'
            [m, c, ~, d] = GaussianDistribution.initParameters(varargin{:});

            if obj.dim ~= d
                error(['Error in class ' class(obj) ': Dimension cannot be changed via update method.']);
            end

            obj.mu = m;
            obj.cov = c;
        end

        function obj = updateCovariance(obj, cov)
            if nargin < 2
                error(['Error in class ' class(obj) ': Too few arguments passed.']);
            end

            if ~Utility.isValidCovarianceMatrix(cov)
                error(['Error in class ' class(obj) ': Argument is not a valid covariance matrix.']);
            end

            if  size(cov, 1) ~= obj.dim
                error(['Error in class ' class(obj) ': Dimension cannot be changed via update method.']);
            end
            
            % Update covariance
            obj.cov = cov;
        end
        
        function obj = updateMu(obj, mu)
            if nargin < 2
                error(['Error in class ' class(obj) ': Too few arguments passed.']);
            end

            if length(mu) ~= obj.dim
                error(['Error in class ' class(obj) ': Dimension cannot be changed via update method.']);
            end
            
            obj.mu = mu;
        end



        %% Getters
        function value = get.Expectation(obj)
            value = obj.mu;
        end

        function value = get.ExpectationXt(obj)
            value = obj.mu';
        end
        
        function value = get.Variance(obj)
            value = obj.cov;
        end

        function value = get.H(obj)
            value = 1/2 * log(det(obj.cov)) + obj.dim/2 * (1 + log(2 * pi)); 
        end
        
        function value = get.Precision(obj)
            [isDiag, diagEl] = Utility.checkAndExtractDiagonal(obj.cov);
            value = Utility.ternary(isDiag, 1./diagEl, NaN);
        end

        function value = get.Value(obj)
            value = mvnrnd(obj.mu, obj.cov)'; % Transpose to get a column vector
        end

        function value = get.ExpectationXtX(obj)
            value = obj.mu' * obj.mu + trace(obj.cov);
        end

        function value = get.ExpectationXXt(obj)
            value = obj.mu * obj.mu' + obj.cov;
        end
    end
end