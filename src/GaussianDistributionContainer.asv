classdef GaussianDistributionContainer < handle
    properties
        distributions       % A list of distributions inside the container
        cols                % Boolean: true when the distributions are columns of a matrix (e.g. W in BPCA)
                            % false when they are rows
    end
    
    properties (Dependent)
        Size                % Number of distributions in the container
        Expectation         % Under the assumption of independence of each component; 
                            % This is a cell array where each entry is an
                            % expectation of one component;
        ExpectationXXt      % Similar to above, each entry is E[XXt]
        ExpectationXtX      % Similar to above, each entry is E[XtX], which is equivalent to E[|X|^2]
        ExpectationC        % 'C' stands for container, and this is expectation of the whole container
        ExpectationCt 
        ExpectationCtC
    end

    methods(Access = private)
        % Helper method that throws an error if index is not valid
        function validateIndex(obj, idx)
            if idx < 1 || idx > obj.Size 
                error(['Error in ' class(obj) ': Index out of range.']); 
            end
        end
    end

    methods
        function obj = GaussianDistributionContainer(dim, cols, numDistributions, prec)
            % [NOTE] All distibutions in the container have the same 'dim' (for now).
            % Constructor can be extended to handle other cases beside the
            % two described below.
            switch nargin
                case {0, 1, 2}
                    error(['Error in class ' class(obj) ': Too few arguments passed.']);
                
                case 3
                    % Constructor with 3 scalar parameters
                    %   All distributions are standard normal multivariate
                    %   Gaussians with the same dimensionality
                    obj.cols = cols;
                    obj.distributions = repmat(GaussianDistribution(), numDistributions, 1); % Preallocate
                    for i = 1:numDistributions
                        obj.distributions(i) = GaussianDistribution(0, 1, dim);
                    end

                case 4
                    % Constructor with 4 scalar parameters
                    %   All distributions are zero-mean normal multivariate
                    %   Gaussians with the same dimensionality and
                    %   different covariances given by precision array
                    if length(prec) ~= dim
                        error(['Error in class ' class(obj) ': Invalid arguments.']);
                    end

                    obj.cols = cols;
                    obj.distributions = repmat(GaussianDistribution(), numDistributions, 1); % Preallocate
                    for i = 1:numDistributions
                        obj.distributions(i) = GaussianDistribution(0, 1./prec(i), dim);
                    end
            end
        end
       


        %% Methods
        function dist = getDistribution(obj, idx)
            % Returns the distribution at index 'idx'
            obj.validateIndex(idx);

            dist = obj.distributions(idx);
        end

        function obj = updateDistribution(obj, idx, dist)
            obj.validateIndex(idx);

            % Updates the distribution at index 'idx'
            obj.distributions(idx) = dist;
        end

        function obj = updateDistributionParams(obj, idx, mu, cov)
            if nargin < 4
                error(['Error in class ' class(obj) ': Too few arguments passed.']);
            end
            obj.validateIndex(idx);

            obj.distributions(idx).updateParameters(mu, cov);
        end

        function obj = updateDistributionMu(obj, idx, mu)
            if nargin < 3
                error(['Error in class ' class(obj) ': Too few arguments passed.']);
            end
            obj.validateIndex(idx);

            obj.distributions(idx).updateMu(mu); % Will raise an exception if we try to change dimension
        end

        % [NOTE] The type of these update methods depends on the current
        % need (e.g. in the update equations for BPCA all covariances are set to the
        % same value). In future more general methods can be added (maybe
        % needed in the update equations of more complex models like GFA).
        function obj = updateAllDistributionsCovariance(obj, cov)
            % Update covariance of all distributions
            if nargin < 2
                error(['Error in class ' class(obj) ': Too few arguments passed.']);
            end
            
            for i=1:obj.Size
                obj.distributions(i).updateCovariance(cov);
            end
        end



        %% Getters
        function value = get.Size(obj)
            value = length(obj.distributions);
        end

        function value = get.Expectation(obj)
            value = cell(1, obj.Size);
            for i = 1:obj.Size
                value{i} = obj.distributions(i).Expectation;
            end
        end

        function value = get.ExpectationXXt(obj)
            value = cell(1, obj.Size);
            for i = 1:obj.Size
                value{i} = obj.distributions(i).ExpectationXXt;
            end
        end
        
        function value = get.ExpectationXtX(obj)
            value = cell(1, obj.Size);
            for i = 1:obj.Size
                value{i} = obj.distributions(i).ExpectationXtX;
            end
        end

        function value = get.ExpectationC(obj)
            value = Utility.ternary(obj.cols, cell2mat(obj.Expectation), cell2mat(obj.Expectation)');
        end

        function value = get.ExpectationCt(obj)
            value = obj.ExpectationC';
        end

        function value = get.ExpectationCtC(obj)
            value = zeros(obj.Size, obj.Size);
            for i = 1:obj.Size
                for j = 1:obj.Size
                    % E[Wt * W] is a matrix where each entry is e.g. E[w1^T *
                    % w2] (w1 and w2 are columns of the matrix W and there
                    % are independent random variable). Given the
                    % independence this is E[w1^T]E[w2],

                    value(i, j) = obj.distributions(i).ExpectationXt * ...
                        obj.distributions(j).Expectation;
                end
            end
        end
    end
end